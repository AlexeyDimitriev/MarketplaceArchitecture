# MarketplaceArchitecture

## Запуск user-service

Запустить сервис можно командой:
`make run-docker-user-service`

Для остановки сервиса следует использовать команду:
`make stop-docker-user-service`

### Health check

После запуска сервиса можно осуществить health-check проверку командой:
`curl -sf http://localhost:$(PORT)/health || (echo "Health check failed" && exit 1)`

Или можно провести проверку без предварительного запуска сервиса:
`make docker-user-service-health-check`

## Архитектура

Диаграмма лежит в diagrams/architecture.md
Для прорисовки диаграммы нужно нажать Ctrl+Shift+V или открыть картинку diagrams/architecture.png

### Используемые домены

- User Domain. Отвечает за информацию о пользователях (персональные данные, номер телефона, является ли пользователь продавцом и т.п.)
- Order Domain. Отвечает за информацию о заказах (получение заказов пользователя, их статус, цена и т.п.)
- Catalog Domain. Отвечает за информацию о товарах в маркетплейсе (название, описание, владелец, стоимость)
- Payment Domain. Отвечает за информацию о транзакциях (реквизиты для оплаты, сумма сделки, акторы)
- Feed Domain. Отвечает за рекомендации товаров пользователю
- Notifications Domain. Отвечает за уведомление пользователей о статусе заказов

### Домены по сервисам

User, Order, Catalog и Payment домены распределены по соответствующим сервисам 1 к 1, так как для каждого из них нужны разные данные, что мешает их объединить (так, например, OrderService не нужны персональные данные пользователя, а CatalogService - данные о заказах). Кроме того, нельзя объединить Payment и Order сервисы, так как Payment Service требует повышенной защиты из-за данных о картах, поэтому необходимо его выделить отдельно

А вот Feed и Notifications домены объединены в один сервис - IndividualService, так как для каждого нужна одна и та же информация - данные о заказах конкретного пользователя, просто первый домен использует их для подбора рекомендаций, а второй - для отправки уведомлений

### Границы владения данными

Из разделения доменов по сервисам и ответственности доменов логично вытекают данные, которыми владеют определенные сервисы, и за что они отвечают:
- User Service. Владеет персональными данными пользователей. Отвечает за регистрацию, авторизацию, проверку, является ли пользователь продавцом
- Order Service. Владеет данными о заказах. Отвечает за создание заказа, изменение статуса, хранит историю заказов
- Catalog Service. Владеет данными о товарах на маркетплейсах. Отвечает за добавление и удаление товара с рынка, показ его характеристик
- Payment Service. Владеет данными, необходимых для оплаты. Отвечает за статус платежа и связь с сервисом оплаты
- Individual Service. Владеет данными о рекомендациях и уведомлениях. Отвечает за подбор товаров в ленте рекомендаций и уведомлении покупателей о статусе заказа

### Альтернативная архитектура

1) Монолит  
Самым простым и легким для критики является сервис-монолит (схема diagrams/architecture_monolith.md). Его плюсы и минусы хорошо известны. Плюсы:
- Монолит дешев
- Его легко тестировать
- Легок в мониторинге

С другой стороны, минусы:
- Его очень сложно масштабировать
- Если он ломается, то ломается весь
- Сложнее настроить безопасность для разных слоев

И при выборе стоит учитывать, что маркетплейс - это подвижная система, которая должна адаптироваться под клиентов. Уже одно это делает костный монолит нерелевантным из-за необходимости масштабировать, поддержания круглосуточной работы и защиты данных пользователей

2) Альтернативные микросервисы  
В основе этой архитектуры лежит идея разделения продавцов и покупателей. В такой системе (см. схему в diagrams/architecture_alternative.md) у пользователя для продаж и покупок разные аккаунты и разный функционал: сервис покупателя имеет доступ к заказам и IndividualService, который здесь тоже отвечает за рекомендации и уведомления, в то время как сервис продавца имеет доступ к каталогу товаров. Обратим внимание, что Payment-домен был включен в сервис заказов

Плюсы:
- Более прозрачное разделение функционала покупателя и продавца

Минусы:
- Необходимость иметь несколько аккаунтов с разным функционалом: продавца и покупателя
- При появлении пересекающихся фич придется дублировать их для продавцов и покупателей
- Платежные данные попадают в OrderService - проблемы с безопасностью

Почему этот вариант не подходит? Слишком большая в долгой перспективе цена за только прозрачность в разделении, а именно - проблемы с пересекающимися фичами. Кроме того, нельзя списывать и большую уязвимость платежных данных

Итоговый вариант архитектуры превосходит альтернативные в гибкости, безопасности, а монолит - еще и в поддержании работы. По этим причинам был выбран именно он